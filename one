#!/bin/bash

BIN_DIR="${HOME}/.local/bin"

ONE_DIR=$(dirname "$0")
#required files
#to just work fine
#check if any of these files is even exist
. ${BIN_DIR}/src_files.sh

#list of packages 
not_graghical_packages=(ffmpeg image-magick go hyperfine julia bat glow zoxide shellcheck dysk)

TRUE=1
FALSE=0

#simple colors
RED="\e[31m"
GREEN="\e[32m"
BLUE="\e[36m"
RESET="\e[00m"
RED_BOLD="\e[31;01m"
GREEN_BOLD="\e[32;01m"
BLUE_BOLD="\e[36;01m"
PURPLE="\e[34m"
PURPLE_BOLD="\e[34;01m"

#Very important vars
TEMP_DIR="/tmp"
DESKTOP_FILE_DIR="${HOME}/.local/share/applications"
ICON_DIR="${HOME}/.local/share/icons"

ERROR=1

# if CWD is set it will not be setted again
# otherewise CWD="$HOME/.local"
CWD=${CWD:="$HOME/.local"}

check_package()
{
	if [[ -n "${APP_URL[$1]}" ]]
	then
		true
	else
		false
	fi 
}

#this function is used to display an error message because an option is not valid
display_error_message()
{
	local NOT_VALID_OPTION=1
	local option="${1}"

	printf "${RED_BOLD}error: ${RESET} ${BLUE_BOLD}${option}${RESET} ${RED}is not a valid option${RESET}\n"
	display_help_message
	exit $NOT_VALID_OPTION
}

#this function is used to return the action the i will use in the program to determine the valid options(install / remove)
return_action()
{
	local option="${1}"

	case "${option}" in
		install | '--install' | '-i')
			echo download
		;;
		remove | '--remove' | '-r')
			echo delete
		;;
		search | '--search' | '-s')
			echo search
		;;
		*)
		;;
	esac
	
}


#this is all valid arguments that oneperson package tool can get from the user
declare -a valid_arguments
valid_arguments[0]='install --install -i --remove -r remove search --search -s'
valid_arguments[1]='list --list -l --help -h help -G --graphical graphical --all all -a init --init -I --version -v version'

#this function checks if a string is in the first or second list of valid arguments and return which one (1 / 2)
check_valid_arguments()
{
	local i

	for i in ${valid_arguments[$1]}
	do
		if [[ $2 == $i ]]
		then
			echo 1
		fi	
	done
}

handle_action()
{
	if [[ -d "${CWD}/$1" ]]
	then
		delete_package $1 -y
	else
		download_package $1
	fi
}

take_action()
{
	local action="${1}"

	if [[ "$action" == 'all' ]]
		then
			for i in ${!APP_URL[@]}
			do
				printf "$i\n"
			done
		elif [[ "${action}" == 'list' ]]
		then
			printf "${GREEN}"
			for i in $(ls "${CWD}/")
			do
				if [[ -n "${APP_URL[${i}]}" && -d "${CWD}/${i}" ]]
				then
					printf "${GREEN_BOLD}%-15s${RESET}${DESCRIPTION[$i]}\n" "${i^}:"
				fi
			done
			printf "${RESET}"
		elif [[ "${action}" == 'graphic' ]]
		then
			zenity_app
		elif [[ "${action}" == 'init' ]]
		then
			setup $2
			exit 0
		elif [[ "${action}" == 'version' ]]
		then
			get_version
			exit 0
		else
			display_help_message
		fi
}

#this function is used to return one of these actions (list all help) if one of these is got (install[] remove[]) it will display the help message
return_friendly_action()
{
	local option="${1}"

	if [[ $(check_valid_arguments 0 ${option}) ]]
	then
		printf "${RED}error:${RESET} the option $i is used witout any package name\n"
		display_help_message
		return $ERROR
	fi
	case "${option}" in
		list | '--list' | '-l')
			echo list
		;;
		all | '--all' | '-a')
			echo all
		;;
		graphic | '--graphic' | '-G')
			echo graphic
		;;
		init | '--init' | '-I')
			echo init
		;;
		version | '--version' | '-v')
			echo version
		;;
		help | '--help' | '-h')
			display_help_message
			return 2
		;;
		*)
		;;
	esac
	return 0
}

#command line argments
package_arguments=("$@")
declare -a valid_packages

declare -i counter=0

for package in "${package_arguments[@]}"
do
	if [[ $counter -eq 0 ]]
	then
		if [[ $# -gt 1 ]]
		then
			if [[ $(check_valid_arguments 1 ${package}) ]]
			then
				printf "${RED}error: ${BLUE} option ${package}${RESET} is used with a package_name?\n"
				display_help_message
				exit $ERROR
			fi
			action=$(return_action "${package}")
			if [[ -z $action ]]
			then
				display_error_message "${package}"
			fi	
		else
			action=$(return_friendly_action "${package}")
			if [[ $? -eq $ERROR ]]
			then
				printf "${RED}error: ${BLUE}${package}${RESET} is used witout package name\n"
				display_help_message
				exit $ERROR
			elif [[ $? -eq 2 ]]
			then
				exit 0
			fi
			if [[ -z $action ]]
			then
				printf "${RED}error: ${RESET}${BLUE}${package}${RESET} no such option\n"
				display_help_message
				exit $ERROR
			fi
			if [[ "$action" == init ]]
			then
				take_action $action $0
			fi
			take_action "$action"
		fi
		((counter++))
		continue
	fi
	((counter++))
	if ! check_package "${package,,}" && [[  $action != 'search' ]]
	then
		printf "${RED_BOLD}error:${RESET} ${BLUE_BOLD}${package}${RESET}${RED} is not found\n${RESET}"	
		exit $ERROR
	else
		valid_packages[$counter - 1]="${package,,}"
	fi
done

#if the counter is 0 that means that there is any command line argument so this will display help message
if [[ $counter -eq 0 ]]
then
	display_help_message
	exit 0
fi

#iterate valid packages and installing them
for i in "${valid_packages[@]}"
do
	if [[ "$action" == 'download' ]]
	then
		if [[ -d "${CWD}/${i}" ]]
		then
			printf "\n${BLUE}$i ${RED}is installed\n${RESET}\n"
		elif enough_storage ${APP_URL[$i]} $i;
		then
			download_package "$i"	
			notify-send -i "${HOME}/COMMON_CORE/one-app/build/assets/logos/$i.png" "one notification" "$i is installed"
		else
			exit 1
		fi

	elif [[ "$action" == 'delete' ]]
	then
		delete_package "$i"
	elif [[ "$action" == 'search' ]]
	then
		search_package "$i"
	fi
done
